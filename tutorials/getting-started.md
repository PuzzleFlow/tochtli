---
layout: default
title: Getting started
---

# Getting started

Okay, let's see Tochtli in action. In this first excersise we will create a server that create website snapshots using [screencap](https://github.com/maxwell/screencap) gem. But before we go any further, let's check the prerequisites (that are not covered by this tutorial). I assume that you:

* Have RabbitMQ set up and running with default configuration
* Have Ruby >= 2.0 installed
* Played with screencap at least once (on my system, even though I had PhantomJS installed, screencap decided to install its own version of it on the first run, which slowed down everything significantly)

OK, now we are ready to go. Tochtli plays nice with Ruby on Rails, however you can use it pretty much anywhere. In this first tutorial we are going to operate on simple Ruby files, with no frameworks or libraries. First, let's create a Gemfile:

{% highlight ruby %}
source 'https://rubygems.org'
gem 'screencap'
gem 'tochtli', github: 'puzzleflow/tochtli'
{% endhighlight %}

Not much to see here, so we may proceed to creating some logic. In Tochtli we use Ruby classes to define messaging API. Besides an abundance of benefits of that, there is one major downside – you have to share the message definitions between client and server in some fashion. Historically, we used separate gems (named like `processing_service_common`) to achieve that, but in our simple example we can just put it i a fiile, which will be required by both client and a server.

{% highlight ruby %}
class CreateScreenMessage < Tochtli::Message
	bind_topic 'screener.create'
	attributes :url, :file
end
{% endhighlight %}

This is a definition of a message that client sends to the server. We want to create a shapshot of a webpage, so we are going to need its URL and a name of the output file. This is pretty obvious with `attribute` method. `bind_topic` may be less obvious. You can think of it as the route by which the message is sent. One message can be bound to one topic and to avoid confusing and cumbersome code, you should also use only one message with a topic. Technically a topic is RabbitMQ's feature and you can read more about it in [one of their excellent tutorials](https://www.rabbitmq.com/tutorials/tutorial-five-ruby.html).

Our one message would be enough to get our little system working, but we want more. Snapshotting can take quite some time and we (or at least I) are interested in how long exactly it takes. To do that, lets implement a reply message:

{% highlight ruby %}
class CreateScreenReplyMessage < Tochtli::Message
	attributes :time
end
{% endhighlight %}

Conventionaly we name replies the same way as 'original' messages, with a `Reply` word inserted as penultimate part. Note that reply message does not have any topic bound. RabbitMQ creates a [reply queue](https://www.rabbitmq.com/direct-reply-to.html), unique for each client, and the message goes through it. Its name is autogenerated and unique.

Before we go into implementing actual client and server there is one more thing left. Tochtli wants you to define the logger. It wants it so bad that if you don't do it, it won't start. With this addition out `common.rb` file looks like that:

{% highlight ruby %}
Bundler.require

Tochtli.logger = Logger.new('tochtli.log')

class CreateScreenMessage < Tochtli::Message
	bind_topic 'screener.create'
	attributes :url, :file
end

class CreateScreenReplyMessage < Tochtli::Message
	attributes :time
end
{% endhighlight %}

## Server

Server in Tochtli uses concept of controllers. So let's define one:

{% highlight ruby %}
require './common'

class ScreenerController < Tochtli::BaseController
	subscribe 'screener.*'

	def create
		start_time = Time.now
		f = Screencap::Fetcher.new(message.url)
		f.fetch output: File.join(__dir__, 'images', message.file)
		total_time = Time.now - start_time
		reply CreateScreenReplyMessage.new(time: total_time)
	end
end
{% endhighlight %}

So, what's goin on here? First of all, we subscribe the controller to a set of topics with a wildcard. Then we define a method `create` which does its capturing stuff, measures time and sends a reply. Hoopefully the convention here is obvious: a part of the topic matching the wildcard is a method name. And our `CreateScreenMessage` is bound to `screener.create`, so after receiving it, the controller calls the correct method. The received message is available with a accessor named `message`. `reply` comes from `Tochtli::BaseController` and sends our `CreateScreenReplyMessage` instance to reply queue I mentioned above.

Now, when we run the file with `bundle exec ruby server.rb`... Nothing happens! That's because wee need to start the controller. Tochtli has a `ControllerManager` singleton (I know... but there are reasons) to take care of that.

{% highlight ruby %}
Tochtli::ControllerManager.instance.start(ScreenerController)
{% endhighlight %}

After we add this line, we run the file again and... still nothing. That's because a controller is spawned within another thread, the program goes on, reaches the end and terminates before we can do anything. For now let's cheat with a infinite loop. We may take a last (for now) look at our server file and start writing the client.

{% highlight ruby %}
require './common'

class ScreenerController < Tochtli::BaseController
	subscribe 'screener.*'

	def create
		start_time = Time.now
		f = Screencap::Fetcher.new(message.url)
		f.fetch output: File.join(__dir__, 'images', message.file)
		total_time = Time.now - start_time
		reply CreateScreenReplyMessage.new(time: total_time)
	end
end

Tochtli::ControllerManager.instance.start(ScreenerController)

loop {}
{% endhighlight %}


## Client

Writing client is really simple. So let's get to the code right away:

{% highlight ruby %}
require './common'

class ScreenerClient < Tochtli::BaseClient
	def create_screen(url, file_name)
		publish CreateScreenMessage.new(url: url, file: file_name)
	end
end

ScreenerClient.new.create_screen(ARGV[0], ARGV[1])
{% endhighlight %}

Not much magic here. The `publish` method comes from `Tochtli::BaseClient` and it's responsible for, well, publishing the message to RabbitMQ. With server fired up, run the file with `bundle exec ruby client.rb http://google.com google.png` and you probably already suspect that I'm just messing with you and that won't work.

That's actually not true.

Even though there was no result in the console, a lot of things happened. First of all, check the `images` directory. If there were no network problems, the file with screenshot shooul be there. Then, have a look inside the log file we defined in our first steps.

```
D, [2015-06-09T17:11:38.878759 #22132] DEBUG -- : [2015-06-09 17:11:38 +0200 AMQP] Publishing message 9e148924-d02e-418c-a1cd-b87f05fd265d to screener.create
D, [2015-06-09T17:11:38.983412 #4566] DEBUG -- : 

AMQP Message CreateScreenMessage at 2015-06-09 17:11:38 +0200
D, [2015-06-09T17:11:39.083386 #4566] DEBUG -- : Processing by ScreenerController#create [Thread: 70100321457120]
D, [2015-06-09T17:11:39.183507 #4566] DEBUG -- : 	Message: {:url=>"http://google.com", :file=>"google.png"}.
D, [2015-06-09T17:11:39.283633 #4566] DEBUG -- : 	Properties: {:content_type=>"application/json", :delivery_mode=>2, :priority=>0, :reply_to=>"amq.gen-Eo6u-Bcz9ultMgiy8C7-qA", :message_id=>"9e148924-d02e-418c-a1cd-b87f05fd265d", :timestamp=>2015-06-09 17:11:38 +0200, :type=>"create_screen_message"}.
D, [2015-06-09T17:11:39.383713 #4566] DEBUG -- : 	Delivery info: exchange: puzzleflow.services, routing_key: screener.create.
D, [2015-06-09T17:11:40.686812 #4566] DEBUG -- : 	Sending  replay on 9e148924-d02e-418c-a1cd-b87f05fd265d to amq.gen-Eo6u-Bcz9ultMgiy8C7-qA: #<CreateScreenReplyMessage:0x007f83018a3a50 @excess_attributes={}, @time=1.202898356, @properties=nil, @id="54e6ec10-4b85-402d-ae3c-011b2a333543">.
D, [2015-06-09T17:11:41.087204 #4566] DEBUG -- : Message 9e148924-d02e-418c-a1cd-b87f05fd265d processed in 2103.8ms.
E, [2015-06-09T17:11:42.088429 #4566] ERROR -- : Message 54e6ec10-4b85-402d-ae3c-011b2a333543 dropped: NO_ROUTE [312]
```

Let me explain what we are looking at. The first two lines (above empty ones) are from the client. It published a message to the correct topic (`screener.create`) and terminated. Publishing is asynchronous so it did not wait for anything. But the server received the message and processed it. It even tried to send a reply that everything is correct, but failed to deliver it because of `NO_ROUTE` error.

Our next task is to maintain the reply queue and use the time from the response to do anything (like, print it on STDOUT). First we want to hold the main program thread until the response comes and only then exit (and `sleep 10` at the end of the file is not a solution). The Tochtli-way of doing it is to use the handler. Normally, handlers are asynchronous and you would have to meddle with condition variables and mutexes. Fortunately there is a simpler way. Enter `SyncMessageHandler`:


{% highlight ruby %}
def create_screen(url, file_name)
	handler = SyncMessageHandler.new
	message = CreateScreenMessage.new(url: url, file: file_name)
	rabbit_client.publish message, handler: handler
	handler.wait!(20)
	puts "Done in #{handler.reply.time} seconds"
end
{% endhighlight %}

You probably already see what I did there. We create a new `SyncMessageHandler` and upon sending the message bind it to it. Then with `handler.wait!(timeout)` we block the thread until message arrival. If it does not happen withing specified number of seconds, an exception is raised. After receiving the response, we may access it via `handler.reply` and write our elapsed time to the console.

Et voilà! We have completed our RPC webpage capturing system.